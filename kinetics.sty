\ProvidesPackage{kinetics}
% This package allows for easy and flexible annotation of vectors and tensors.
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{ifthen}  % try to remove dependency 
\usepackage{etoolbox}
\usepackage{xstring}
\usepackage{keycommand}[2010/04/27] % requires a recent version. v3.1415 (2010/04/27)

%% === Symbols and names ==

\newcommand{\InertiaTensorSymbol}{\textrm{I}}
\newcommand{\InertiaTensorName}{I}
\newcommand{\VelocitySymbol}{v}
\newcommand{\VelocityName}{v}
\newcommand{\AccelerationSymbol}{a}
\newcommand{\AccelerationName}{a}
\newcommand{\AngularVelocitySymbol}{\Omega}
\newcommand{\AngularVelocityName}{w}
\newcommand{\AngularAccelerationSymbol}{\alpha}
\newcommand{\AngularAccelerationName}{alpha}
\newcommand{\TorqueSymbol}{\mathcal{T}}
\newcommand{\TorqueName}{T}
\newcommand{\ForceSymbol}{F}
\newcommand{\ForceName}{F}
\newcommand{\ImpulseSymbol}{p}
\newcommand{\ImpulseName}{p}
\newcommand{\AngularImpulseSymbol}{\mathcal{H}}
\newcommand{\AngularImpulseName}{H}
\newcommand{\DisplacementSymbol}{\textrm{r}}
\newcommand{\DisplacementName}{r}
\newcommand{\UnitVectorSymbol}{e}
\newcommand{\UnitVectorName}{e}
\newcommand{\TransformationSymbol}{R}
\newcommand{\TransformationName}{R}
\newcommand{\HomogenousTransformationSymbol}{T}
\newcommand{\HomogenousTransformationName}{T}
\newcommand{\GenericVectorSymbol}{v}
\newcommand{\GenericVectorName}{v}


%% === Helper functions: List processing tools ====



% Converts its second argument into a list structure
% usage: \fromcsv{\mylist}{foo,bar,baz}
\newcommand{\fromcsv}[2]{
  \renewcommand*{\do}[1]{\listadd{#1}{##1}}%
  \docsvlist{#2}%
}

% Converts it's second argument into a list structure, after edef'ing them
% usage: \fromcsve{\mylist}{foo,bar,baz}
\newcommand{\fromcsve}[2]{%
  \edef\temp{#2}%
  \renewcommand*{\do}[1]{\listadd{#1}{##1}}%
  \expandafter\docsvlist\expandafter{\temp}%
}

% Counts the number of elements in a list
% usage: \listcnt{\mycounter}{\mylist}
\newcommand{\listcnt}[2]{%
  \renewcommand*{\do}[1]{\stepcounter{#1}}%
  \dolistloop{#2}%
}

\newcounter{tempcountN}
\newcounter{tempcounti}

% A haskell-like function.
% Splits the list in \init (a list of all elements but the last) and \last.
\newcommand{\initlast}[1]{%
\let\init\undefined%
\let\last\undefined%
\ifdef{#1}{%
  \setcounter{tempcountN}{0}%
  \listcnt{tempcountN}{#1}%
  \setcounter{tempcounti}{1}%
  \renewcommand*{\do}[1]{%
    \ifnumless{\value{tempcounti}}{\value{tempcountN}}{%
      \listadd\init{##1}%
    }{%
      \def\last{##1}%
    }%
    \stepcounter{tempcounti}%
  }%
  \dolistloop{#1}%
}{}%
}

% Joins a list be means of a separator
% usage: \join{sep}{list}
\newcommand{\join}[2]{%
  \def\sep{#1}%
  \def\last{0}%
  \let\mylist\undefined%
  \fromcsv{\mylist}{#2}%
  \initlast{\mylist}%
  \renewcommand*{\do}[1]{##1\sep}%
  \ifdef{\init}{\dolistloop{\init}}{}\ifdef{\last}{\last}{}%
}

% Joins a list with a comma as separator
\newcommand{\combine}[1]{%
  \join{,}{#1}%
}


% Assertion oneorzero
% asserts that a list of values only has one non-empty member or none.
\newcommand{\oneorzero}[1]{%
  \let\mylist\undefined%
  \fromcsve{\mylist}{#1}%
  \ifdef{\mylist}{%
    \setcounter{tempcountN}{0}%
    \listcnt{tempcountN}{\mylist}%
    \renewcommand*{\do}[1]{##1}%
    \ifnumless{\value{tempcountN}}{2}{\dolistloop{\mylist}}{\error{Oneorzero assertion failed. More than one non-empty list value was found: #1 (count \number\value{tempcountN})}}%
  }{}%
}


\newcommand{\ifkey}[3]{\ifthenelse{\equal{\commandkey{#1}}{}}{#3}{#2}}
\newcommand{\haskey}[1]{\not \equal{\commandkey{#1}}{}}

\newcommand{\ARROW}[1]{\vec{#1}}
\newcommand{\DARROW}[1]{\overset{\leftrightarrow}{#1}}
\newcommand{\DARROWBOLD}[1]{\overset{\leftrightarrow}{\mathbf{#1}}}
\newcommand{\BOLD}[1]{\mathbf{#1}}
\newcommand{\UNDERLINE}[1]{\underline{#1}}
\newcommand{\DUNDERLINE}[1]{\underset{=}{#1}}
\newcommand{\DUNDERLINEBOLD}[1]{\underset{=}{\mathbf{#1}}}

\newcommand{\prettydefault}{prettydefault}
\newcommand{\flatdefault}{flatdefault}
%
%   outermodifiers(
%                                      u
%                     ul                                 ur
%                             innermodifiers(symbol)
%                     ll                                 lr
%                                      l
%                                                            )
%
%
%  Symbol formatters
% ------------------
% vecsymbolstyle:    How a true vector should be displayed
% vecexprstyle:      How a column matrix representation of a vector should be displayed
% vecindexedstyle:   How an indexed element of a column matrix representation of a vector should be displayed
% tenssymbolstyle:   How a tensor should be displayed
% tensexprstyle:     How a matrix representation of a tensor should be displayed
% tensindexedstyle:  How an indexed element of a matrix representation of a tensor should be displayed
%
% choose from \ARROW, \DARROW, \DARROWBOLD, \BOLD, \UNDERLINE, \DUNDERLINE, \DUNDERLINEBOLD
%  All of these options are in fact latex commands that take one argument.
%  You could create you're own style formatter as such:
%
%  \newcommand{\HAT}[1]{\hat{#1}}
%
%  Differential formatters
% -------------------
% modifierDiffInner:  A modifier that works on the inner symbol level and can add decorators for differentials
% modifierDiffouter:  A modifier that works on the outer symbol level and can add decorators for differentials
%
% choose from: \DOTEXPR , \DDTVEC
%
% All of these options are in fact latex commands that take one argument and check for commandkeys.
%
% 
% Skew formatters
% ------------------
% 
% modifierSkewOuter: A modifier that works on the outer symbol level and can add decorators for skew
% 
% choose from: \SKEWTILDE


\makeatletter
\let\edefprotect\protected@edef
\makeatother

\newcommand{\keyedfun}[3]{
  \edefprotect\myargs{[ #3] }
  %\edefprotect\myargt{ #2 }
  \def\mycommand{\csname #1\endcsname }
  \expandafter\mycommand\myargs{#2}
}

\newcommand{\commandkeyblank}[3]{
\edefprotect\mytemp{\commandkey{#1}}
\expandafter\ifstrequal\expandafter {\mytemp}{}{#2}{#3}
}


\newcommand{\commandkeysequal}[4]{
\edefprotect\mytempa{\commandkey{#1}}
\edefprotect\mytempb{\commandkey{#2}}
\ifx \mytempa \mytempb
  #3
\else
  #4
\fi
%\expandafter\ifstrequal\expandafter {\mytempa}{\mytempb}{#3}{#4} % this does not work, no idea why
}

\newcommand{\commandkeyequal}[4]{
\edefprotect\mytempa{\commandkey{#1}}
\edefprotect\mytempb{#2}
\ifx \mytempa \mytempb
  #3
\else
  #4
\fi
}

\let\modifierDiffOuter\DDTVEC
%

\let\vecsymbolstyle\ARROW
\let\vecexprstyle\UNDERLINE
\let\vecindexedstyle\UNDERLINE
\let\tenssymbolstyle\DARROWBOLD
\let\tensexprstyle\DUNDERLINEBOLD
\let\tensindexedstyle\DUNDERLINEBOLD

% Omitting mechanism:
%
% \let\omitfoo1
%    makes that foo argument will not be displayed
% \let\omitall1
%    make sthat everything will be omitted
% \newcommand{\omitlogicfoo}{1}
%    makes that \omitlogicfoo will be tested to see if foo must be omitted
% 

\newcommand{\omitlogicexpressedIn}[1]{%
 %\IfStrEq{t}{Transformation}{}{}
 %\ifthenelse{\equals{5}{6}}{}{}
  %bar
  %\ifthenelse{\equal{\storedkey{expressedIn}}{\storedkey{wrt}}}{}{#1}%
 %}{foo #1}%
 #1%
}

\newcommand{\checkomit}[2]{%
 \ifcsundef{omitall}{%
  \ifcsundef{omit#1}{%
   \ifcsdef{omitlist#1}{%
     \ifinlistcs{#2}{omitlist#1}{}{%
      \ifcsundef{omitlogic#1}{#2}{%
        \csname omitlogic#1\endcsname{#2}%
      }%
     }%
   }{%
    \ifcsundef{omitlogic#1}{#2}{%
      \csname omitlogic#1\endcsname{#2}%
    }%
   }%
  }{}%
 }{}%
}


\newcommand{\checkkey}[1]{%
  \checkomit{#1}{\storedkey{#1}}%
}

\newcommand{\ifblanc}[3]{\ifstrequal{#1}{}{#2}{#3}}

\newcommand{\TensSymbol}[1]{%
  \commandkeyblankt{expressedIn}{%
    \tenssymbolstyle{#1}%
  }{%
    \tensexprstyle{#1}%
  }%
}

\newcommand{\VecSymbol}[1]{%
  \commandkeyblankt{expressedIn}{%
    \vecsymbolstyle{#1}%
  }{%
    \vecexprstyle{#1}%
  }%
}

\makeatletter

\def\abc{abc}
\def\xyz{xyz}
% storekeys
% Accepts a csv list of commandkey names.
% For each commandkey it stores the edef'ed content in a variable.
% arg: csv list
\newcommand{\storekeys}[1]{%
  \renewcommand*{\do}[1]{%
    \edefprotect\mytempa{\commandkey{##1}}%
    \expandarg
    \IfSubStr*{\expandafter\string\mytempa}{keycmd}{%
      \expandafter\edefprotect\csname storedkey##1\endcsname{}%
    }{%
      \expandafter\edefprotect\csname storedkey##1\endcsname{\commandkey{##1}}%
    }%
  }%
  \docsvlist{#1}%
}

\makeatother

\newcommand{\storedkey}[1]{\csexpandonce{storedkey#1}}

\newcommand{\commandkeyblankt}[3]{%
\edefprotect\mytemp{\storedkey{#1}}%
\expandafter\ifstrequal\expandafter {\mytemp}{}{#2}{#3}%
}

\newcommand{\identity}[1]{#1}

% How vector notation is represented:    
%
%                                      u
%                     ul                                 ur
%                                    symbol
%                     ll                                 lr
%                                      l
%
\newcommand{\SymbolMarkupu}[1]{\overset{\commandkey{u}}{#1}}
\newcommand{\SymbolMarkupl}[1]{\underset{\commandkey{l}}{#1}}
\newkeycommand\SymbolMarkup[ul,ll,lr,ur,u,l][1]{%
 \ensuremath{%
    \commandkeyblank{u}{\let\myopu\identity}{\let\myopu\SymbolMarkupu}%
    \commandkeyblank{l}{\let\myopl\identity}{\let\myopl\SymbolMarkupl}%
    \myopl{%
      \myopu{%
	  {_{\commandkey{ll}}^{\commandkey{ul}}}{#1}_{\commandkey{lr}}^{\commandkey{ur}}%
      }%
    }%
  }%
}

\newcommand{\ifboolkey}[3]{\ifnumequal{\commandkey{#1}}{1}{#2}{#3}}

% A d/dt notation is used when the vector/tensor is true
\newcommand{\DDTVEC}[1]{%
  \commandkeyblankt{diff}{#1}{%
    \commandkeyblankt{expressedIn}{%
      \frac{\mathrm{d}#1}{{^\commandkey{diff}}\mathrm{d}t}%
    }{%
      \commandkeysequal{diff}{expressedIn}{%
	#1%
      }{%
	{_{\commandkey{expressedIn}}^{\commandkey{diff}}}\tensexprstyle{\TransformationSymbol} . #1%
      }%
    }%
  }%
}

% An overhead dot will be used when the vector/tensor is expressed
\newcommand{\DOTEXPR}[1]{%
  \commandkeyblankt{expressedIn}{#1}{%
    \commandkeyblankt{diff}%
      {#1}%
      {\dot{#1}}%
  }%
}

\let\modifierDiffInner\DOTEXPR
\let\modifierDiffOuter\DDTVEC

\newcommand{\SKEWTILDE}[1]{%
  \ifboolkey{skew}{\ensuremath{\overset{\sim}{#1}}}{#1}%
}

\let\modifierSkewOuter\SKEWTILDE

\newkeycommand\SymbolMarkupVectorModifier[ul,ll,lr,ur,u,l,diff,expressedIn,bool skew=false][1]{%
 \storekeys{ul,ll,lr,ur,u,l}%
 \ensuremath{%
    \modifierDiffOuter{%
      \modifierSkewOuter{%
	\SymbolMarkup[
	    ul=\storedkey{ul},
	    ll=\storedkey{ll},
	    lr=\storedkey{lr},
	    ur=\storedkey{ur},
	    u=\storedkey{u},
	    l=\storedkey{l}
	]{\modifierDiffInner{#1}}%
      }%
    }%
  }%
}




% \storedkey{object},\storedkey{actingOn},\storedkey{end}

\newcommand{\VECTORPRETTYDEFAULT}[2]{%
    \storekeys{around,object,wrt,expressedIn,diff,on,end,start,wrt,from,id,index,at}%
    \SymbolMarkupVectorModifier[
        ul=\noexpand\combine{\checkkey{object},\checkkey{id},\checkkey{on},\checkkey{end}},
        ll=\noexpand\combine{\checkkey{start},\checkkey{wrt},\checkkey{from}},
        ur=\checkkey{expressedIn},
        lr=\noexpand\combine{\checkkey{id},\checkkey{index}},
        u=\noexpand\combine{\checkkey{around},\checkkey{at}},
        diff=\storedkey{diff},
        expressedIn=\storedkey{expressedIn}
    ]{\VecSymbol{#1}}%
}

\newcommand{\VECTORFLAT}[2]{
    \storekeys{around,object,expressedIn,diff,on,end,start,wrt,from,id,index,at}%
    {\tt%
    \ifthenelse{\equal{\commandkey{expressedIn}}{}}{\error{cannot represent this: I need expressedIn}}{}%
    \ifthenelse{\(\not \equal{\commandkey{diff}}{}\)}{%
      \ifthenelse{\equal{\commandkey{diff}}{\commandkey{expressedIn}}}{d}{\error{cannot represent this: diff and expressedIn don't match}}%
    }{}%
    #2\_%
      \oneorzero{\checkkey{object},\checkkey{end},\checkkey{on}}%
      \oneorzero{\checkkey{wrt},\checkkey{start},\checkkey{from}}%
      \oneorzero{\checkkey{expressedIn}}%
      \oneorzero{\checkkey{around}}%
    }%
}

\newcommand{\UNITVECTORPRETTYDEFAULT}[2]{
    \storekeys{frame,axis,expressedIn,index,components,diff,id}%
    \def\axis{\storedkey{axis}}%
    \def\mysymbol{%
        \ifthenelse{\equal{\axis}{x} \or \equal{\axis}{1}}{i}{%
          \ifthenelse{\equal{\axis}{y} \or \equal{\axis}{2}}{j}{%
            \ifthenelse{\equal{\axis}{z} \or \equal{\axis}{3}}{k}{#1}%
          }%
        }%
    }%
    \SymbolMarkupVectorModifier[
        ur=\checkkey{expressedIn},
        ul=\checkkey{frame},
        lr=\checkkey{index},
        diff=\storedkey{diff},
        expressedIn=\storedkey{expressedIn}
    ]{\VecSymbol{\mysymbol}}%
}

\newcommand{\TENSORPRETTYDEFAULT}[2]{%
    \storekeys{around,object,wrt,expressedIn,diff,actingOn,end,start,actingFrom,id,index,frame}%
    \SymbolMarkupVectorModifier[
        ul=\noexpand\combine{\checkkey{object},\checkkey{id},\checkkey{frame}},
        ur=\checkkey{expressedIn},
        lr=\noexpand\combine{\checkkey{id},\checkkey{index}},
        ll=\checkkey{wrt},
        u=\checkkey{around},
        expressedIn=\storedkey{expressedIn}
    ]{\TensSymbol{#1}}%
}

\newcommand{\TENSORFLAT}[2]{
    \storekeys{around,object,wrt,expressedIn,diff,actingOn,end,start,actingFrom,id,index,frame}%
    {\tt%
    \ifthenelse{\equal{\commandkey{expressedIn}}{}}{\error{cannot represent this: I need expressedIn}}{}%
    \ifthenelse{\(\not \equal{\commandkey{diff}}{}\)}{%
      \ifthenelse{\equal{\commandkey{diff}}{\commandkey{expressedIn}}}{d}{\error{cannot represent this: diff and expressedIn don't match}}%
    }{}%
    #2\_%
      \oneorzero{\checkkey{object},\checkkey{frame}}%
      \oneorzero{\checkkey{wrt}}%
      \oneorzero{\checkkey{expressedIn}}%
      \oneorzero{\checkkey{around}}%
    }%
}

\let\vectorformatter\VECTORPRETTYDEFAULT
\let\tensorformatter\TENSORPRETTYDEFAULT
\let\unitvectorformatter\UNITVECTORPRETTYDEFAULT


%% === omitting functionality ==
\newcommand{\setomitif}[2]{
  \listcseadd{omitlist#2}{#1}
}

\newenvironment{omitenv}[1]{
  \renewcommand*{\do}[1]{
    \setomit{##1}
  }
  \docsvlist{#1}
}{

}

%
% \setomit{all}
% \setomit{object}
% \setomit{wrt=0}
\newcommand{\setomit}[1]{
  \IfSubStr*{#1}{=}{
    \StrBefore{#1}{=}[\mykey]
    \StrBehind{#1}{=}[\myvalue]
    \listcseadd{omitlist\mykey}{\myvalue}
    %\setomitif{\mykey}{\myvalue}
  }{
    \expandafter\let\csname omit#1\endcsname1
  }
}


\newcommand{\setomitting}[1]{
  \renewcommand*{\do}[1]{
    \setomit{##1}
  }
  \docsvlist{#1}
}

\newcommand{\omitting}[2]{\begingroup\setomitting{#1}#2\endgroup}






\newcommand{\error}[1]{?#1?}


\newcommand{\genericformatter}[2]{%
  \def\vectorcontext{#2}%
  #1{\csname #2Symbol\endcsname}{\csname #2Name\endcsname}%
}

\newkeycommand\AngularImpulse[around,object,wrt,expressedIn,diff,components,id]{%
  \genericformatter{\vectorformatter}{AngularImpulse}
}

\newkeycommand\Torque[around,on,from,expressedIn,diff,components,id]{%
  \genericformatter{\vectorformatter}{Torque}
}

\newkeycommand\Force[on,from,at,expressedIn,diff,components,id]{%
  \genericformatter{\vectorformatter}{Force}
}

\newkeycommand\Displacement[start,end,expressedIn,index,diff,components,id]{%
  \genericformatter{\vectorformatter}{Displacement}
}

\newkeycommand\AngularVelocity[object,wrt,expressedIn,index,diff,components,id,bool skew=false]{%
  \genericformatter{\vectorformatter}{AngularVelocity}
}

\newkeycommand\AngularAcceleration[object,wrt,expressedIn,index,diff,components,id]{%
  \genericformatter{\vectorformatter}{AngularAcceleration}
}

\newkeycommand\Velocity[object,wrt,expressedIn,index,diff,components,id]{%
  \genericformatter{\vectorformatter}{Velocity}
}

\newkeycommand\Impulse[object,wrt,expressedIn,index,diff,components,id]{%
  \genericformatter{\vectorformatter}{Impulse}
}

\newkeycommand\Acceleration[object,wrt,expressedIn,index,diff,components,id]{%
  \genericformatter{\vectorformatter}{Acceleration}
}


\newkeycommand\InertiaTensor[object,around,expressedIn,index,diff,id]{%
  \genericformatter{\tensorformatter}{InertiaTensor}
}

\newkeycommand\GenericVector[object,wrt,expressedIn,index,diff,components,id,bool skew=false]{%
  \genericformatter{\vectorformatter}{GenericVector}
}

\newkeycommand\UnitVector[frame,axis,expressedIn,index,components,diff,id]{%
 \genericformatter{\unitvectorformatter}{UnitVector}
}

\newkeycommand\Transformation[frame,wrt,expressedIn,diff,id]{%
  \genericformatter{\tensorformatter}{Transformation}
}

\newkeycommand\HomogenousTransformation[frame,wrt,expressedIn,diff,id,bool homogenous=true]{%
  \genericformatter{\tensorformatter}{HomogenousTransformation}
}


% Helper functions
% Fundamental question: don't these defy the purpose?
\newkeycommand\disp[expressedIn,index][2]{\edef\mytemp{\commandkey{expressedIn}}\edef\mytempp{\commandkey{index}}\expandafter\Displacement[start=#1,end=#2,expressedIn=\mytemp,index=\mytempp]}
\newkeycommand{\ev}[expressedIn,index][2]{\edef\temp{\commandkey{expressedIn}}\edef\tempp{\commandkey{index}}\UnitVector[axis=#1,frame=#2,expressedIn=\temp,index=\tempp]}
\newcommand{\trans}[2]{\Transformation[frame=#1,wrt=#2,expressedIn=#2]}


\newcommand{\Htrans}[2]{\HomogenousTransformation[frame=#1,wrt=#2,expressedIn=#2]}

\newkeycommand\VectorComponents[expressedIn][1]{%
  \storekeys{expressedIn}%
  \renewcommand*{\do}[1]{%
    ##1 \\%
  }%
  \begin{pmatrix}%
  \docsvlist{#1}%
  \end{pmatrix}_\checkkey{expressedIn}%
}




\endinput
