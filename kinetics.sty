\ProvidesPackage{kinetics}
% This package allows for easy and flexible annotation of vectors and tensors.
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{ifthen}  % try to remove dependency 
\usepackage{etoolbox}
\usepackage{xstring}
\usepackage{ulem}
\usepackage{keycommand}[2010/04/27] % requires a recent version. v3.1415 (2010/04/27)

%% === Symbols and names ==

\newcommand{\InertiaTensorSymbol}{\textrm{I}}
\newcommand{\InertiaTensorName}{I}
\newcommand{\VelocitySymbol}{v}
\newcommand{\VelocityName}{v}
\newcommand{\AccelerationSymbol}{a}
\newcommand{\AccelerationName}{a}
\newcommand{\AngularVelocitySymbol}{\Omega}
\newcommand{\AngularVelocityName}{w}
\newcommand{\AngularAccelerationSymbol}{\alpha}
\newcommand{\AngularAccelerationName}{alpha}
\newcommand{\TorqueSymbol}{\mathcal{T}}
\newcommand{\TorqueName}{T}
\newcommand{\ForceSymbol}{F}
\newcommand{\ForceName}{F}
\newcommand{\ImpulseSymbol}{p}
\newcommand{\ImpulseName}{p}
\newcommand{\AngularImpulseSymbol}{\mathcal{H}}
\newcommand{\AngularImpulseName}{H}
\newcommand{\DisplacementSymbol}{\textrm{r}}
\newcommand{\DisplacementName}{r}
\newcommand{\UnitVectorSymbol}{e}
\newcommand{\UnitVectorName}{e}
\newcommand{\TransformationSymbol}{R}
\newcommand{\TransformationName}{R}
\newcommand{\HomogenousTransformationSymbol}{T}
\newcommand{\HomogenousTransformationName}{T}
\newcommand{\GenericVectorSymbol}{v}
\newcommand{\GenericVectorName}{v}


%% === Helper functions: List processing tools ====



% Converts its second argument into a list structure
% usage: \fromcsv{\mylist}{foo,bar,baz}
\newcommand{\fromcsv}[2]{
  \renewcommand*{\do}[1]{\listadd{#1}{##1}}%
  \docsvlist{#2}%
}

% Converts it's second argument into a list structure, after edef'ing them
% usage: \fromcsve{\mylist}{foo,bar,baz}
\newcommand{\fromcsve}[2]{%
  \edefprotect\temp{#2}%
  \renewcommand*{\do}[1]{\listadd{#1}{##1}}%
  \expandafter\docsvlist\expandafter{\temp}%
}

% Counts the number of elements in a list
% usage: \listcnt{\mycounter}{\mylist}
\newcommand{\listcnt}[2]{%
  \renewcommand*{\do}[1]{\stepcounter{#1}}%
  \dolistloop{#2}%
}

\newcounter{tempcountN}
\newcounter{tempcounti}

% A haskell-like function.
% Splits the list in \init (a list of all elements but the last) and \last.
\newcommand{\initlast}[1]{%
\let\init\undefined%
\let\last\undefined%
\ifdef{#1}{%
  \setcounter{tempcountN}{0}%
  \listcnt{tempcountN}{#1}%
  \setcounter{tempcounti}{1}%
  \renewcommand*{\do}[1]{%
    \ifnumless{\value{tempcounti}}{\value{tempcountN}}{%
      \listadd\init{##1}%
    }{%
      \def\last{##1}%
    }%
    \stepcounter{tempcounti}%
  }%
  \dolistloop{#1}%
}{}%
}

% Joins a list be means of a separator
% usage: \join{sep}{list}
\newcommand{\join}[2]{%
  \def\sep{#1}%
  \def\last{0}%
  \let\mylist\undefined%
  \fromcsv{\mylist}{#2}%
  \initlast{\mylist}%
  \renewcommand*{\do}[1]{##1\sep}%
  \ifdef{\init}{\dolistloop{\init}}{}\ifdef{\last}{\last}{}%
}

% Joins a list be means of a separator
% usage: \join{sep}{list}
\newcommand{\joinr}[3]{%
  \def\sep{#2}%
  \def\last{0}%
  \let\mylist\undefined%
  \fromcsve{\mylist}{#3}%
  \initlast{\mylist}%
  \def#1{}%
  \renewcommand*{\do}[1]{\edefprotect#1{#1##1\sep}}%
  \ifdef{\init}{\dolistloop{\init}}{}\ifdef{\last}{\edefprotect#1{#1\last}}{}%
}

% Joins a list with a comma as separator
\newcommand{\combine}[1]{%
  \join{,}{#1}%
}

% Joins a list with a comma as separator
\newcommand{\combiner}[2]{%
  \joinr{#1}{,}{#2}%
}


% Assertion oneorzero
% asserts that a list of values only has one non-empty member or none.
\newcommand{\oneorzero}[1]{%
  \let\mylist\undefined%
  \fromcsve{\mylist}{#1}%
  \ifdef{\mylist}{%
    \setcounter{tempcountN}{0}%
    \listcnt{tempcountN}{\mylist}%
    \renewcommand*{\do}[1]{##1}%
    \ifnumless{\value{tempcountN}}{2}{\dolistloop{\mylist}}{\error{Oneorzero assertion failed. More than one non-empty list value was found: #1 (count \number\value{tempcountN})}}%
  }{}%
}

% counting starts at zero
% \listindex{1}{\mylist} gives the second element
% lookup time is linear
\newcommand{\listindex}[2]{
  \let\mylist\undefined%
  \fromcsv{\mylist}{#2}%
  \ifdef{\mylist}{%
    \setcounter{tempcounti}{0}%
    \renewcommand*{\do}[1]{
       \ifnumequal{\value{tempcounti}}{#1}{%
	##1%
      }{}%
      \stepcounter{tempcounti}%
    }%
    \dolistloop{\mylist}%
   }{}%
}

% counting starts at zero
% \listindex{1}{\mylist} gives the scond element
% lookup time is linear
\newcommand{\listindexr}[3]{
  \let\mylist\undefined%
  \let#1\undefined%
  \fromcsve{\mylist}{#3}%
  \ifdef{\mylist}{%
    \setcounter{tempcounti}{0}%
    \renewcommand*{\do}[1]{
       \ifnumequal{\value{tempcounti}}{#2}{%
	\def#1{##1}%
      }{}%
      \stepcounter{tempcounti}%
    }%
    \dolistloop{\mylist}%
   }{}%
}

\newcommand{\ifkey}[3]{\ifthenelse{\equal{\commandkey{#1}}{}}{#3}{#2}}
\newcommand{\haskey}[1]{\not \equal{\commandkey{#1}}{}}

\newcommand{\ARROW}[1]{\vec{#1}}
\newcommand{\DARROW}[1]{\overset{\leftrightarrow}{#1}}
\newcommand{\DARROWBOLD}[1]{\overset{\leftrightarrow}{\mathbf{#1}}}
\newcommand{\BOLD}[1]{\mathbf{#1}}
\newcommand{\UNDERLINE}[1]{\uline{#1}}
\newcommand{\DUNDERLINE}[1]{\uuline{#1}}
\newcommand{\DUNDERLINEBOLD}[1]{\uuline{\mathbf{#1}}}

\newcommand{\prettydefault}{prettydefault}
\newcommand{\flatdefault}{flatdefault}
%
%   outermodifiers(
%                                      u
%                     ul                                 ur
%                             innermodifiers(symbol)
%                     ll                                 lr
%                                      l
%                                                            )
%
%
%  Symbol formatters
% ------------------
% vecsymbolstyle:    How a true vector should be displayed
% vecexprstyle:      How a column matrix representation of a vector should be displayed
% vecindexedstyle:   How an indexed element of a column matrix representation of a vector should be displayed
% tenssymbolstyle:   How a tensor should be displayed
% tensexprstyle:     How a matrix representation of a tensor should be displayed
% tensindexedstyle:  How an indexed element of a matrix representation of a tensor should be displayed
%
% choose from \ARROW, \DARROW, \DARROWBOLD, \BOLD, \UNDERLINE, \DUNDERLINE, \DUNDERLINEBOLD
%  All of these options are in fact latex commands that take one argument.
%  You could create you're own style formatter as such:
%
%  \newcommand{\HAT}[1]{\hat{#1}}
%
%  Differential formatters
% -------------------
% modifierDiffInner:  A modifier that works on the inner symbol level and can add decorators for differentials
% modifierDiffouter:  A modifier that works on the outer symbol level and can add decorators for differentials
%
% choose from: \DOTEXPR , \DDTVEC
%
% All of these options are in fact latex commands that take one argument and check for commandkeys.
%
% 
% Skew formatters
% ------------------
% 
% modifierSkewOuter: A modifier that works on the outer symbol level and can add decorators for skew
% 
% choose from: \SKEWTILDE


\makeatletter
\let\edefprotect\protected@edef
\makeatother

\newcommand{\keyedfun}[3]{
  \edefprotect\myargs{[ #3] }
  %\edefprotect\myargt{ #2 }
  \def\mycommand{\csname #1\endcsname }
  \expandafter\mycommand\myargs{#2}
}

\newcommand{\commandkeyblank}[3]{
\edefprotect\mytemp{\commandkey{#1}}
\expandafter\ifstrequal\expandafter {\mytemp}{}{#2}{#3}
}


\newcommand{\commandkeysequal}[4]{
\edefprotect\mytempa{\commandkey{#1}}
\edefprotect\mytempb{\commandkey{#2}}
\ifx \mytempa \mytempb
  #3
\else
  #4
\fi
%\expandafter\ifstrequal\expandafter {\mytempa}{\mytempb}{#3}{#4} % this does not work, no idea why
}

\newcommand{\commandkeyequal}[4]{
\edefprotect\mytempa{\commandkey{#1}}
\edefprotect\mytempb{#2}
\ifx \mytempa \mytempb
  #3
\else
  #4
\fi
}

\let\modifierDiffOuter\DDTVEC
%

\let\vecsymbolstyle\ARROW
\let\vecexprstyle\UNDERLINE
\let\vecindexedstyle\UNDERLINE
\let\tenssymbolstyle\DARROWBOLD
\let\tensexprstyle\DUNDERLINEBOLD
\let\tensindexedstyle\DUNDERLINEBOLD

% Omitting mechanism:
%
% \let\omitfoo1
%    makes that foo argument will not be displayed
% \let\omitall1
%    make sthat everything will be omitted
% \newcommand{\omitlogicfoo}{1}
%    makes that \omitlogicfoo will be tested to see if foo must be omitted
% 

% 
\newcommand{\omitlogicexpressedIn}[1]{%
 \ifdef{\vectorcontext}{%
  \IfStrEq*{\vectorcontext}{Transformation}{%
    \ifthenelse{\equal{\storedkey{expressedIn}}{\storedkey{wrt}}}{\let\result1}{}%
  }{}%
  \IfStrEq*{\vectorcontext}{HomogenousTransformation}{%
    \ifthenelse{\equal{\storedkey{expressedIn}}{\storedkey{wrt}}}{\let\result1}{}%
  }{}%
 }{}%
}

% result is returned as \result
% \undefined -> don't omit
% anything else -> omit
%  \checkomit{wrt}{value}
\newcommand{\checkomit}[2]{%
 \let\result\undefined
 \ifcsundef{omitall}{%
  \ifcsundef{omit#1}{%
   \ifcsdef{omitlist#1}{%
     \xifinlistcs{#2}{omitlist#1}{\let\result1}{%
      \ifcsundef{omitlogic#1}{}{%
        \csname omitlogic#1\endcsname{#2}%
      }%
     }%
   }{%
    \ifcsundef{omitlogic#1}{}{%
      \csname omitlogic#1\endcsname{#2}%
    }%
   }%
  }{\let\result1}%
 }{\let\result1}%
}


\newcommand{\checkkey}[1]{%
  \ifcsdef{shouldomit#1}{}{\storedkey{#1}}%
}

\newcommand{\ifblanc}[3]{\ifstrequal{#1}{}{#2}{#3}}

\newcommand{\TensSymbol}[1]{%
  \commandkeyblankt{expressedIn}{%
    \tenssymbolstyle{#1}%
  }{%
    \tensexprstyle{#1}%
  }%
}

\newcommand{\VecSymbol}[1]{%
  \commandkeyblankt{expressedIn}{%
    \vecsymbolstyle{#1}%
  }{%
    \vecexprstyle{#1}%
  }%
}

\makeatletter

\def\abc{abc}
\def\xyz{xyz}
% storekeys
% Accepts a csv list of commandkey names.
% For each commandkey it stores the edef'ed content in a variable.
% arg: csv list
\newcommand{\storekeys}[1]{%
  \renewcommand*{\do}[1]{%
    \edefprotect\mytempa{\commandkey{##1}}%
    \expandarg
    \IfSubStr*{\expandafter\string\mytempa}{keycmd}{%
      \expandafter\edefprotect\csname storedkey##1\endcsname{}%
    }{%
      \expandafter\edefprotect\csname storedkey##1\endcsname{\commandkey{##1}}%
    }%
  }%
  \docsvlist{#1}%
  \calcomits{#1}%
}

% calculate omits
\newcommand{\calcomits}[1]{%
  \renewcommand*{\do}[1]{%
    \edefprotect\mytempa{\storedkey{##1}}%
    \checkomit{##1}{\mytempa}%
    \expandafter\let\csname shouldomit##1\endcsname\result
  }%
  \docsvlist{#1}%
}

\makeatother

\newcommand{\storedkey}[1]{\csexpandonce{storedkey#1}}

\newcommand{\commandkeyblankt}[3]{%
\edefprotect\mytemp{\storedkey{#1}}%
\expandafter\ifstrequal\expandafter {\mytemp}{}{#2}{#3}%
}

\newcommand{\identity}[1]{#1}

% How vector notation is represented:    
%
%                                      u
%                     ul                                 ur
%                                    symbol
%                     ll                                 lr
%                                      l
%
\newcommand{\SymbolMarkupu}[1]{\overset{\commandkey{u}}{#1}}
\newcommand{\SymbolMarkupl}[1]{\underset{\commandkey{l}}{#1}}
\newkeycommand\SymbolMarkup[ul,ll,lr,ur,u,l][1]{%
 \ensuremath{%
    \commandkeyblankt{u}{\let\myopu\identity}{\let\myopu\SymbolMarkupu}%
    \commandkeyblankt{l}{\let\myopl\identity}{\let\myopl\SymbolMarkupl}%
    \myopl{%
      \myopu{%
	  {_{\commandkey{ll}}^{\commandkey{ul}}}{#1}_{\commandkey{lr}}^{\commandkey{ur}}%
      }%
    }%
  }%
}

\newcommand{\ifboolkey}[3]{\ifnumequal{\commandkey{#1}}{1}{#2}{#3}}

% A d/dt notation is used when the vector/tensor is true
\newcommand{\DDTVEC}[1]{%
  \commandkeyblankt{diff}{#1}{%
    \commandkeyblankt{expressedIn}{%
      \frac{\mathrm{d}#1}{{^\commandkey{diff}}\mathrm{d}t}%
    }{%
      \commandkeysequal{diff}{expressedIn}{%
	#1%
      }{%
	{_{\commandkey{expressedIn}}^{\commandkey{diff}}}\tensexprstyle{\TransformationSymbol} . #1%
      }%
    }%
  }%
}

% An overhead dot will be used when the vector/tensor is expressed
\newcommand{\DOTEXPR}[1]{%
  \commandkeyblankt{expressedIn}{#1}{%
    \commandkeyblankt{diff}%
      {#1}%
      {\dot{#1}}%
  }%
}

\let\modifierDiffInner\DOTEXPR
\let\modifierDiffOuter\DDTVEC

\newcommand{\SKEWTILDE}[1]{%
  \edefprotect\myskew{\storedkey{skew}}%
  \IfSubStr*{\myskew}{1}{\tilde{#1}}{#1}%
} % \sim

\let\modifierSkewOuter\SKEWTILDE

\let\modifierSkewInner\identity

\newkeycommand\SymbolMarkupVectorModifier[ul,ll,lr,ur,u,l,diff,expressedIn,skew][1]{%
 \storekeys{ul,ll,lr,ur,u,l}%
 \ensuremath{%
    \modifierDiffOuter{%
      \modifierSkewOuter{%
	\SymbolMarkup[
	    ul=\storedkey{ul},
	    ll=\storedkey{ll},
	    lr=\storedkey{lr},
	    ur=\storedkey{ur},
	    u=\storedkey{u},
	    l=\storedkey{l}
	]{\modifierDiffInner{\modifierSkewInner{#1}}}%
      }%
    }%
  }%
}




% \storedkey{object},\storedkey{actingOn},\storedkey{end}

\newcommand{\VECTORPRETTYDEFAULT}[2]{%
    \storekeys{around,object,wrt,expressedIn,diff,on,end,start,wrt,from,id,index,at,skew}%
    \combiner{\myu}{\checkkey{around},\checkkey{at}}% u and l must be edef'able
    \SymbolMarkupVectorModifier[
        ul=\noexpand\combine{\checkkey{object},\checkkey{id},\checkkey{on},\checkkey{end}},
        ll=\noexpand\combine{\checkkey{start},\checkkey{wrt},\checkkey{from}},
        ur=\checkkey{expressedIn},
        lr=\noexpand\combine{\checkkey{id},\checkkey{index}},
        u=\myu,
        diff=\storedkey{diff},
        expressedIn=\storedkey{expressedIn},
        skew=\storedkey{skew}
    ]{\VecSymbol{#1}}%
}

\newcommand{\VECTORFLAT}[2]{
    \storekeys{around,object,expressedIn,diff,on,end,start,wrt,from,id,index,at,skew}%
    {\tt%
    \ifthenelse{\equal{\commandkey{expressedIn}}{}}{\error{cannot represent this: I need expressedIn}}{}%
    \ifthenelse{\(\not \equal{\commandkey{diff}}{}\)}{%
      \ifthenelse{\equal{\commandkey{diff}}{\commandkey{expressedIn}}}{d}{\error{cannot represent this: diff and expressedIn don't match}}%
    }{}%
    #2\_%
      \oneorzero{\checkkey{object},\checkkey{end},\checkkey{on}}%
      \oneorzero{\checkkey{wrt},\checkkey{start},\checkkey{from}}%
      \oneorzero{\checkkey{expressedIn}}%
      \oneorzero{\checkkey{around}}%
    }%
}

\newcommand{\UNITVECTORPRETTYDEFAULT}[2]{
    \storekeys{frame,axis,expressedIn,index,components,diff,id}%
    \def\axis{\storedkey{axis}}%
    \ifthenelse{\equal{\axis}{x} \or \equal{\axis}{1}}{\let\omitaxis1}{%
      \ifthenelse{\equal{\axis}{y} \or \equal{\axis}{2}}{\let\omitaxis1}{%
	\ifthenelse{\equal{\axis}{z} \or \equal{\axis}{3}}{\let\omitaxis1}{}%
      }%
    }%
    \calcomits{frame,axis,expressedIn,index,components,diff,id}
    \def\mysymbol{%
        \ifthenelse{\equal{\axis}{x} \or \equal{\axis}{1}}{\imath}{%
          \ifthenelse{\equal{\axis}{y} \or \equal{\axis}{2}}{\jmath}{%
            \ifthenelse{\equal{\axis}{z} \or \equal{\axis}{3}}{k}{#1}%
          }%
        }%
    }%
    \SymbolMarkupVectorModifier[
        ur=\checkkey{expressedIn},
        ul=\checkkey{frame},
        lr=\noexpand\combine{\checkkey{axis},\checkkey{index}},
        diff=\storedkey{diff},
        expressedIn=\storedkey{expressedIn}
    ]{\VecSymbol{\mysymbol}}%
}

\newcommand{\UNITDYADPRETTYDEFAULT}[2]{
    \storekeys{frame,axis,expressedIn,index,components,diff,id}%
    \listindexr{\axisone}{0}{\storedkey{axis}}%
    \listindexr{\axistwo}{1}{\storedkey{axis}}%
    \ifdef{\axistwo}{}{\let\axistwo\axisone}%
    \UnitVector[frame=\storedkey{frame},axis=\axisone,expressedIn=\storedkey{expressedIn}]%
    \omitting{frame}{\UnitVector[frame=\storedkey{frame},axis=\axistwo,expressedIn=\storedkey{expressedIn}]}%
}

\newcommand{\TENSORPRETTYDEFAULT}[2]{%
    \storekeys{around,object,wrt,expressedIn,diff,actingOn,end,start,actingFrom,id,index,frame}%
    \SymbolMarkupVectorModifier[
        ul=\noexpand\combine{\checkkey{object},\checkkey{id},\checkkey{frame}},
        ur=\checkkey{expressedIn},
        lr=\noexpand\combine{\checkkey{id},\checkkey{index}},
        ll=\checkkey{wrt},
        u=\checkkey{around},
        expressedIn=\storedkey{expressedIn}
    ]{\TensSymbol{#1}}%
}

\newcommand{\TENSORFLAT}[2]{
    \storekeys{around,object,wrt,expressedIn,diff,actingOn,end,start,actingFrom,id,index,frame}%
    {\tt%
    \ifthenelse{\equal{\commandkey{expressedIn}}{}}{\error{cannot represent this: I need expressedIn}}{}%
    \ifthenelse{\(\not \equal{\commandkey{diff}}{}\)}{%
      \ifthenelse{\equal{\commandkey{diff}}{\commandkey{expressedIn}}}{d}{\error{cannot represent this: diff and expressedIn don't match}}%
    }{}%
    #2\_%
      \oneorzero{\checkkey{object},\checkkey{frame}}%
      \oneorzero{\checkkey{wrt}}%
      \oneorzero{\checkkey{expressedIn}}%
      \oneorzero{\checkkey{around}}%
    }%
}

\let\vectorformatter\VECTORPRETTYDEFAULT
\let\tensorformatter\TENSORPRETTYDEFAULT
\let\unitvectorformatter\UNITVECTORPRETTYDEFAULT
\let\unitdyadformatter\UNITDYADPRETTYDEFAULT

%% === omitting functionality ==
\newcommand{\setomitif}[2]{
  \listcseadd{omitlist#2}{#1}
}

\newenvironment{omitenv}[1]{
  \renewcommand*{\do}[1]{
    \setomit{##1}
  }
  \docsvlist{#1}
}{

}

%
% \setomit{all}
% \setomit{object}
% \setomit{wrt=0}
\newcommand{\setomit}[1]{
  \IfSubStr*{#1}{=}{
    \StrBefore{#1}{=}[\mykey]
    \StrBehind{#1}{=}[\myvalue]
    \listcseadd{omitlist\mykey}{\myvalue}
    %\setomitif{\mykey}{\myvalue}
  }{
    \expandafter\let\csname omit#1\endcsname1
  }
}


\newcommand{\setomitting}[1]{
  \renewcommand*{\do}[1]{
    \setomit{##1}
  }
  \docsvlist{#1}
}

\newcommand{\omitting}[2]{\begingroup\setomitting{#1}#2\endgroup}






\newcommand{\error}[1]{?#1?}


\newcommand{\genericformatter}[2]{%
  \def\vectorcontext{#2}%
  #1{\csname #2Symbol\endcsname}{\csname #2Name\endcsname}%
}

\newkeycommand\AngularImpulse[around,object,wrt,expressedIn,diff,components,id]{%
  \genericformatter{\vectorformatter}{AngularImpulse}%
}

\newkeycommand\Torque[around,on,from,expressedIn,diff,components,id]{%
  \genericformatter{\vectorformatter}{Torque}%
}

\newkeycommand\Force[on,from,at,expressedIn,diff,components,id]{%
  \genericformatter{\vectorformatter}{Force}%
}

\newkeycommand\Displacement[start,end,expressedIn,index,diff,components,id]{%
  \genericformatter{\vectorformatter}{Displacement}%
}

\newkeycommand\AngularVelocity[object,wrt,expressedIn,index,diff,components,id,bool skew=false]{%
  \genericformatter{\vectorformatter}{AngularVelocity}%
}

\newkeycommand\AngularAcceleration[object,wrt,expressedIn,index,diff,components,id]{%
  \genericformatter{\vectorformatter}{AngularAcceleration}%
}

\newkeycommand\Velocity[object,wrt,expressedIn,index,diff,components,id]{%
  \genericformatter{\vectorformatter}{Velocity}%
}

\newkeycommand\Impulse[object,wrt,expressedIn,index,diff,components,id]{%
  \genericformatter{\vectorformatter}{Impulse}%
}

\newkeycommand\Acceleration[object,wrt,expressedIn,index,diff,components,id]{%
  \genericformatter{\vectorformatter}{Acceleration}%
}


\newkeycommand\InertiaTensor[object,around,expressedIn,index,diff,id]{%
  \genericformatter{\tensorformatter}{InertiaTensor}%
}

\newkeycommand\GenericVector[object,wrt,expressedIn,index,diff,components,id,bool skew=false]{%
  \genericformatter{\vectorformatter}{GenericVector}%
}

\newkeycommand\UnitVector[frame,axis,expressedIn,index,components,diff,id]{%
 \genericformatter{\unitvectorformatter}{UnitVector}%
}

\newkeycommand\UnitDyad[frame,axis,expressedIn,index,components,diff,id]{%
 \genericformatter{\unitdyadformatter}{UnitVector}%
}

\newkeycommand\Transformation[frame,wrt,expressedIn,diff,id,index]{%
  \genericformatter{\tensorformatter}{Transformation}%
}

\newkeycommand\HomogenousTransformation[frame,wrt,expressedIn,diff,id,index]{%
  \genericformatter{\tensorformatter}{HomogenousTransformation}%
}


% Helper functions
% Fundamental question: don't these defy the purpose?
\newkeycommand\disp[expressedIn,index][2]{\edefprotect\mytemp{\commandkey{expressedIn}}\edef\mytempp{\commandkey{index}}\expandafter\Displacement[start=#1,end=#2,expressedIn=\mytemp,index=\mytempp]}
\newkeycommand{\ev}[expressedIn,index][2]{\edefprotect\temp{\commandkey{expressedIn}}\edef\tempp{\commandkey{index}}\UnitVector[axis=#1,frame=#2,expressedIn=\temp,index=\tempp]}
\newcommand{\trans}[2]{\Transformation[frame=#1,wrt=#2,expressedIn=#2]}


\newcommand{\Htrans}[2]{\HomogenousTransformation[frame=#1,wrt=#2,expressedIn=#2]}

\newkeycommand\VectorComponents[expressedIn,bool skew=false,base][1]{%
  \def\vectorcontext{VectorComponents}%
  \storekeys{expressedIn,skew,base}%
  \edefprotect\myskew{\storedkey{skew}}%
  \IfSubStr*{\myskew}{1}{%
    \begin{pmatrix}%
    0 & -\left(\listindex{2}{#1}\right) & \listindex{1}{#1} \\%
    \listindex{2}{#1} & 0 & -\left(\listindex{0}{#1}\right) \\%
    -\left(\listindex{1}{#1}\right) & \listindex{0}{#1} & 0 \\%
    \end{pmatrix}_{\checkkey{expressedIn}}%
   }{%
    \commandkeyblankt{base}{%
      \renewcommand*{\do}[1]{%
	##1 \\%
      }%
      \begin{pmatrix}%
      \docsvlist{#1}%
      \end{pmatrix}_{\checkkey{expressedIn}}%
    }{%
      \listindex{0}{#1} \UnitVector[frame=\storedkey{base},axis=1,expressedIn=\storedkey{expressedIn}] +%
      \listindex{1}{#1} \UnitVector[frame=\storedkey{base},axis=2,expressedIn=\storedkey{expressedIn}] +%
      \listindex{2}{#1} \UnitVector[frame=\storedkey{base},axis=3,expressedIn=\storedkey{expressedIn}] %
    }
   }%
}


\newkeycommand\TensorComponents[expressedIn,bool diagonal=true,base][1]{%
  \def\vectorcontext{TensorComponents}%
  \storekeys{expressedIn,diagonal,base}%
  \edefprotect\mydiag{\storedkey{diagonal}}%
  \IfSubStr*{\mydiag}{1}{%
    \commandkeyblankt{base}{
      \begin{pmatrix}%
      \listindex{0}{#1} & 0 & 0 \\%
      0 & \listindex{1}{#1} & 0 \\%
      0 & 0 & \listindex{2}{#1} \\%
      \end{pmatrix}_{\checkkey{expressedIn}}%
    }{%
      \listindex{0}{#1} \UnitDyad[frame=\storedkey{base},axis=1,expressedIn=\storedkey{expressedIn}] +%
      \listindex{1}{#1} \UnitDyad[frame=\storedkey{base},axis=2,expressedIn=\storedkey{expressedIn}] +%
      \listindex{2}{#1} \UnitDyad[frame=\storedkey{base},axis=3,expressedIn=\storedkey{expressedIn}]%
    }%
   }{%
    \renewcommand*{\do}[1]{%
      ##1 \\%
    }%
    \begin{pmatrix}%
    \docsvlist{#1}%
    \end{pmatrix}_{\checkkey{expressedIn}}%
   }%
}

\newkeycommand\HomogenousTransformationPrimitive[type,axis,bool components=false][1]{
  \def\vectorcontext{HomogenousTransformationPrimitive}%
  \storekeys{type,axis,components}%
  \edefprotect\mycomponents{\storedkey{components}}%
  \edefprotect\myaxis{\storedkey{axis}}%
  \edefprotect\mytype{\storedkey{type}}%
  \IfSubStr*{\mycomponents}{1}{%
    \IfStrEqCase*{\mytype}{%
      {R}{%
	\def\ca{\cos\left(#1\right)}%
	\def\sa{\sin\left(#1\right)}%
	\IfStrEqCase*{\myaxis}{%
	  {x}{%
	    \begin{pmatrix}%
	    1 & 0 & 0 & 0\\%
	    0 & \ca & -\sa & 0 \\%
	    0 & \sa & \ca  & 0 \\%
	    0 & 0 & 0 & 1 \\%
	    \end{pmatrix}%
	  }%
	  {y}{%
	    \begin{pmatrix}%
	    \ca & 0 & \sa & 0\\%
	    0 & 1 & 0 & 0 \\%
	    -\sa & 0 & \ca & 0 \\%
	    0 & 0 & 0 & 1 \\%
	    \end{pmatrix}%
	  }%
	  {z}{
	    \begin{pmatrix}%
	    \ca & -\sa & 0 &0\\%
	    \sa & \ca & 0 & 0 \\%
	    0 & 0 & 1 & 0 \\%
	    0 & 0 & 0 & 1 \\%
	    \end{pmatrix}%
	  }%
	}%
      }%
      {tr}{%
	\begin{pmatrix}%
	0 & 0 & 0 & \listindex{0}{#1}\\%
	0 & 0 & 0 & \listindex{1}{#1} \\%
	0 & 0 & 1 & \listindex{2}{#1} \\%
	0 & 0 & 0 & 1 \\%
	\end{pmatrix}%
      }%
    }%
  }{%
    \IfStrEqCase*{\mytype}{%
      {R}{%
	\IfStrEqCase*{\myaxis}{%
	  {x}{%
	    \TRx(#1)%
	  }%
	  {y}{%
	    \TRy(#1)%
	  }%
	  {z}{
	    \TRz(#1)%
	  }%
	}%
      }%
      {tr}{%
	\Tr(#1)%
      }%
    }%
  }%
}
%todo: components. Genmatrix?

\endinput
